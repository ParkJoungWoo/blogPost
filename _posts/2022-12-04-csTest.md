---
layout: post
title: "CS 공부 정리"
subtitle: 정리
categories: cs
tags: [cs]
---
# 현대 CS 테스트 준비를 위한 문서입니다.

## 운영체제
### 스레드
프로세스 : 프로그램 + 프로세스 제어 블록(PCB)

운영체제는 프로그램을 메모리에 가져오고 PCB를 작성.

프로세스의 진행 과정
```
new -> ready -> running -> waiting -> exit
```
프로세스의 구조
```
Code 프로그램 명령이 위치하는 곳
Data 전역 변수나 static 변수 할당을 위해 존재
Stack 지역 변수, 인자 값 저장 위한 공간
Heap Java new를 통한 동적 할당을 위한 공간
```
스레드 : 프로세스가 생성되면 CPU 스케줄러는 프로세스가 해야 할 일을 CPU에 전달하고 CPU가 실제 작업을 수행한다.(CPU 스케줄러가 CPU에 전달하는 일 하나가 스레드이다.)

OS입장에서 작업 단위는 프로세스, CPU입장에서 작업 단위는 스레드이다.

스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap영역은 공유한다.

`Java Thread` : JVM이 운영체제 역할을 한다.\
자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블럭이다.
> main() 메소드가 수행되면서 하나의 스레드가 실행된다.

스레드 : 하나의 작업을 동시에 수행하려면 여러 개의 프로세스를 실행해야하고 각각 메모리를 할당해야한다. 그에 반해 스레드는 낮은 메모리를 할당.

자바 메모리 관리 : `STACK, HEAP`

자바의 메모리는 Stack, Heap영역으로 구분.
Stack 영역
- Heap에서 생성된 객체의 주소를 저장
- 기본 타입의 실제 값을 저장
- 각 지역 변수들은 scope에 맞는 Stack 영역을 가진다.
- Thread는 각자 Stack을 가진다.
### 페이지 테이블 할당 방법
### LRU
가장 오랫동안 참조되지 않은 페이지를 교체하는 기법.\
페이지 교체 알고리즘 예시 : FIFO, LFU, LRU 기법이 있다.
```
FIFO -> 적재된 시간을 기준으로 교체 페이지 선정
    최근에 들어온 페이지를 우선 교체
    먼저 들어온 페이지가 오래 상주하는 문제 발생
LFU -> 가장 적은 횟수를 참조하는 페이지 교체
    교체대상이 여러개면 가장 오래 사용하지 않은 페이지를 교체
LRU -> 가장 오랫동안 참조되지 않은 페이지 교체
    참조되면 top으로 이동
OPT -> 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체
    (구현이 불가능)
MFU -> 참조 횟수가 가장 많은 페이지를 교체
```
### RR
RR -> 시분할 시스템을 위해 설계된 선점형 스케줄링\
프로세스들의 우선순위를 두지 않고 시간단위로 CPU를 할당하는 방식의 CPU 스케줄링 알고리즘.

프로세스 스케줄링 : CPU를 사용하려고 하는 프로세스들 사이의 우선순위를 관리하는 일.

디스크 스케줄링 : 디스크를 사용하려고 하는 프로세스들 사이의 우선순위를 관리하는 일.

스케줄링 -(처리율, CPU 이용율을 증가/오버헤드/응답시간/반환시간/대기시간을 최소화하기 위한 기법)

- 비선점/ 선점 스케줄링
    - 비선점 스케줄링 : 프로세스가 (실행-대기),(실행-종료)의 상태전이가 있을 때 적용
    - 선점 스케줄링 : (실행-대기),(실행-준비),(대기-준비),(수행-종료) 모든 상태 변화에서 적용

비선점 - 이미 할당된 CPU를 다른 프로세스가 강제로 뺏을 수 없다.

- FIFO : 선입선출
- SJF : 점유율이 짧은 프로세스에 CPU 먼저 할당
- HRN : 대기시간, 서비스시간 이용
    - HRN 공식 : 우선순위 = (대기시간 + 서비스 시간)/서비스 시간 = 높은 것 부터

선점 - 하나의 프로세스가 CPU를 할당 받아 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있다.(시분할에 적합)
- SRT : SJF을 선점 형태로 변경한 기법 CPU 시간이 짧은 프로세스에 CPU를 먼저 할당.
- RR : 프로세스 사이에 우선순위를 두지 않고 순서대로 시간단위로 CPU를 할당
- MQ : 다단계 큐, 프로세스를 특정 그룹으로 분류할 수 있을 때 그룹에 따라 다른 준비 상태 큐를 사용하는 기법.
### 데드락
> 두개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해 다음 처리를 하지 못하는 상태

무한히 다음 자원을 기다리는 상황.
> 데드락 발생 조건
1. 상호 배제
    - 자원은 한번에 한 프로세스만 사용할 수 있다.
2. 점유 대기
    - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야함.
3. 비선점
    - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없다.
4. 순환 대기
    - 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다.

교착상태(데드락) 예방 & 회피 방법
1. 예방
    - 교착 상태 발생 조건중 하나를 제거하면서 해결
2. 회피
    - 은행원 알고리즘
        - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사=교착 상태 회피
        - 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 기다리기.
## 네트워크
### TCP/IP 개념
컴퓨터와 네트워크기기 간 통신을 하기 위해서는 서로 같은 방법으로 통신해야한다.\
-> 이를 프로토콜이라고 한다.\
TCP/IP는 인터넷과 관련된 프로콜을 의미.
> TCP/IP : 애플리케이션 - 트랜스포트 - 네트워크 - 링크 4계층으로 구성되어 있다.

애플리케이션 계층 : 유저에게 제공되는 통신의 움직임(HTTP)\
트랜스포트 계층 : 컴퓨터 사이의 데이터 흐름을 제공(TCP/UDP)\
네트워크 계층 : 네트워크 상에서 패킷의 이동을 다루는 계층, 패킷은 전송하는 데이터의 최소 단위.\
링크 계층 : 네트워크에 접속하는 하드웨어적인 면을 다룬다.

애플리케이션 계층에서 하위 계층으로 가면서 해당 계층의 정보를 헤더에 추가하는 과정 = 캡슐화\
하위 계층에서 애플리케이션 계층으로 가면서 헤더의 정보를 제거하는 과정 = 역캡슐화

### IP 프로토콜 개념
IP는 Internet Protocol의 약자이다 + 네트워크 층에 해당한다.\
IP의 역할은 개개의 패킷을 상대방에게 전달...\
전달하기 위해서 (IP주소와 MAC주소가 중요)\
IP 주소는 각 노드에 부여된 주소를 가리키고 MAC 주소는 각 네트워크 카드에 할당되 고유의 주소이다. IP는 변경가능하지만 MAC 주소는 변경할 수 없다.

통신은 ARP(Address Resolution Protocol)이라는 프로토콜이 사용된다.\
IP 통신은 MAC 주소에 의존해서 통신한다. 인터넷에서 통신 상대가 같은 랜선 내에 있을 확률은 매우 낮고 여러 컴퓨터, 네트워크 기기를 중계해 상대방에게 도착한다.\
이때 ARP 프로토콜이 사용된다. ARP는 주소를 해결하기 위한 프로토콜, 수신지의 IP 주소를 바탕으로 MAC 주소를 조사할 수 있다.
### 브로드 캐스트
유니 캐스팅 : 하나의 송신자가 다른 하나의 송신자에게 데이터를 전송하는 방식.(MAC 주소를 기반으로 상대측 IP 주소를 목적지로 하는 1대1 통신방식)\
-> 유니 캐스팅은 네트워크 효율이 저하된다.

브로드 캐스팅 : 송신 호스트가 전송한 데이터가 네트워크에 연결된 모든 호스트에 전송되는 방식.\
로컬에 붙어있는 모든 네트워크 장비에 의사와 상관 없이 모두 보내는 방식.\
브로드 캐스팅 주소는 미리 정해져 있다 : FF:FF:FF:FF:FF:FF\
데이터를 수신할 필요가 없는 호스트들에게도 데이터가 전송.. 불필요한 인터럽트가 발생

멀티 캐스팅 : UDP를 기반으로 특정한 하나 이상의 수신자들에게 데이터를 전송하는 방식.(멀티 캐스팅 전송을 위한 특별한 그룹 주소를 사용하기 때문 D 클래스 주소 IP)

### 서브넷 마스크
서브넷 : 네트워크를 분할함

A 클래스의 대규모 네트워크를 작은 네트워크로 분할하면 브로드캐스트로 전송되는 패킷의 범위를 좁힐 수 있다.\
네트워크를 분할하기 -> subneting(서브네팅)\
분할 한 네트워크 -> subnet(서브넷)

서브네팅을 할 경우 어디까지가 네트워크 ID이고 어디가 호스트 ID인지 판단하기 어려움.. -> 서브넷 마스크 값을 활용

서브넷 마스크는 네트워크 ID와 호스트 ID를 식별하기 위한 값.\
서브네팅이 되면 네트워크 ID + 호스트 ID 에서
> 네트워크 ID + 서브넷 ID + 호스트 ID로 변경된다.

1. IP 주소에는 반드시 서브넷 마스크가 있다.
2. 서브넷 마스크는 기본적으로 255와 0으로 이루어져 있다.
3. 255는 네트워크 부분, 0은 호스트 부분이다.
4. 255로 된 부분은 무시하고 0으로 된 부분에서 IP를 나눠쓰는 혹은 IP를 쪼갠다.

IP를 쪼개는 이유 -> IP주소가 모자라기 때문
>서브넷 마스크의 형태는 IP 주소와 똑같이 32비트 2진수(IP 주소와 AND 연산하기 위해서이다.)

서브넷 마스크를 사용하는 이유 : 브로드캐스트 영역(네트워크)를 나누기 위함이다.

```
192.168.0.3/24
IP주소 : 192.168.0.3
서브넷 마스크 : 255.255.255.0

192.168.0.3/25
IP주소 : 192.168.0.3
서브넷 마스크 : 255.255.255.128

C클래스 네트워크를 26개의 서브넷으로 나누기
255.255.255.
00000000
VVVVV000 -> 248 (2*2*2*2*2 >= 26이므로)

A클래스 표준 네트워크 서브넷 클래스 
255.0.0.0
B클래스 표준 네트워크 서브넷 클래스 
255.255.0.0
.
.
.
```
## 자료구조
### 이진 트리
트리 -> 모양이 뒤집어 놓은 나무와 같다고 해서 작명됨.

순환되면 트리가 아니다.
```
시작점 -> root
끝 점 -> leaves
root의 레벨 0
root 자식의 레벨 1
root 자식의 자식 레벨 2
.
.
.
```
이진트리(최대 두 개인 노드들로 구성된 트리) -> 정이진트리, 완전이진트리, 균형이진트리 가 있다.

- 정이진트리 : 모든 레벨에서 노드들이 꽉 채워진 이진트리
- 완전이진트리 : 마지막 레벨을 제외한 모든 레벨에서 노드들이 채워짐
- 균형이진트리 : 모든 잎새노드의 깊이 차이가 1인 트리.

트리 순회 순서 : preorder, inorder, postorder(루트의 위치에 따라)


### 힙 구조
힙 자료구조 == 완전 이진 트리를 기초로 하는 자료구조

마지막을 제외한 모든 노드에서 자식들이 꽉 채워진 이진트리를 의미한다.

힙은 최대힙과 최소힙으로 나눠진다.\
최대 힙 = 부모 노드의 값이 자식노드들의 값보다 항상 크고, 

최소힙은 부모노드의 값이 자식노드의 값보다 항상 작다.
### 맵
key와 value로 이루어진 자료구조

key의 중복을 허용하지 않는다. (값은 중복되어도 상관 X)

HashMap : key와 value의 쌍으로만 구성, 순서는 보장하지 않는다.

TreeMap : key의 값을 이용해 순서대로 정렬하여 데이터를 저장하는 자료구조

LinkedHashMap : 데이터를 입력한 순서대로 쌓아지며 데이터를 저장하는 자료구조
## 알고리즘
### 다익스트라
다익스트라 알고리즘 : 최단경로 탐색 알고리즘

최단 경로는 여러 개의 최단 경로로 이루어져있다 + 다이나믹 프로그래밍


## 프로그래밍 일반
### 구조체 선언, 크기
```c
typedef struct student
{
    char a;
    int c;
    char b;
}
크기 = 12바이트
ㅁㅁㅁㅁ/ㅁㅁㅁㅁ/ㅁㅁㅁㅁ
char/int/char
int 4바이트
char 1바이트(구조체 포함은 4바이트)
double 8바이트

typedef struct student
{
    char a;
    int c;
    double b;
}
ㅁㅁㅁㅁ/ㅁㅁㅁㅁ/ㅁㅁㅁㅁㅁㅁㅁㅁ
char/int/double
크기 = 16바이트
typedef struct student
{
    char a;
    double b;
    int c;
}
ㅁㅁㅁㅁㅁㅁㅁㅁ/ㅁㅁㅁㅁㅁㅁㅁㅁ/ㅁㅁㅁㅁㅁㅁㅁㅁ
char/double/int

구조체는 가장 큰 자료형 * n의 배수로 이루어져 있다.
typedef struct student
{
  char a;
  char c;
  char b;
  char ee;
  char eee;
  int e;
  char g;
}ss;
크기 = 16바이트
```
## 데이터베이스
### 데이터 베이스 설계
```
요구분석
개념적 설계 : 개념 스키마, 트랜잭션 모델링, E-R 모델
정보 모델링, 개념화
논리적 설계 : 목표 DBMS에 맞는 스키마 설계(관계형 데이터 베이스에서 테이블을 설계하는 단계)
물리적 설계 : 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터 베이스로 변환(반응시간, 공간활용도, 트랜잭션 처리량 고려)
구현
```
- 도메인 : 원자값들의 집합
- 속성 : 릴레이션을 구성하는 각각의 열, 속성 수 = 차수
- 튜플 : 릴레이션을 구성하는 각가의 행
- 후보키 : 식별하기 위해 사용되는 속성들의 부분 집합
- 기본키 : 후보키 중 선택한 주키
- 대체키 : 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키(보조키)
- 슈퍼키 : 유일성은 만족하지만 최소성을 만족하지 않는 키
- 외래키 : 다른 테이블의 기본키를 가져온 것.
### Isolation Level
동시에 여러 트랜잭션이 처리될 때 
- 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있을지 결정하는 것.
1. READ UNCOMMITTED
    - 각 트랜잭션에서의 변경 내용이 commit이나 rollback 여부에 상관 없이 다른 트랜잭션에서 값을 읽을 수 있다.
    - 정합성에 문제가 많은 격리 수준이기 때문에 사용하는 것을 권장하지 않는다.
    - `dirty read`현상이 발생한다.
2. READ COMMITTED
    - 대부분의 격리 수준.
    - `dirty read`현상은 나타나지 않는다.
    - 실제 테이블 값을 가져오는 것이 아닌 `undo 영역`에 `백업된 레코드`에서 값을 가져온다.
    - 하지만 똑같은 SELECT를 실행했을 때 항상 같은 결과가 나타남을 보장하지 않는다.
3. REPEATABLE READ
    - 읽을 때마다 같은 값을 받아와야 한다.
    - Undo 공간에 백업해두고 실제 레코드 값을 변경한다.
    - 백업된 데이터는 불필요하다고 판단되면 주기적으로 삭제한다.
    - `PHANTOM READ` 다른 트랜잭션에 의해 레코드가 보였다 안보였다하는 현상(쓰기 잠금을 걸어야 한다.)
4. SERIALIZABLE
    - 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준
    - 성능 측면에서 동시 처리 성능이 가장 낮다.
    - `PHANTOM READ`가 발생하지 않지만 거의 사용되지 않는다.
### SQL
### commit, rollback
트랜잭션 : 데이터베이스의 논리적 연산단위.

- 원자성 : All Or Nothing
- 일관성 : 트랜잭션이 수행하기 전과 후 모두 내용에 문제가 있으면 안된다.
- 고립성 : 트랜잭션이 수행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과 X
- 지속성 : 한번 성공적으로 수행되면 데이터베이스 내용은 영구적으로 저장.

commit -> 
- 데이터에 대한 변경 사항이 데이터 베이스에 반영
- 모든 사용자는 결과를 볼 수 있다.
- 행에 대한 잠금이 풀리고 다른 사용자들이 행을 조작할 수 있다.

roll back ->
- 데이터에 대한 변경 사항이 취소된다.
- 이전 데이터는 다시 재저장된다.
- 행에 대한 잠금이 풀리고 다른 사용자들이 행을 조작할 수 있다.
## 컴퓨터 구조

## 전산기초
### 부동 소수점
-314.625를 예시로..

부호비트 1
지수비트 8
가수 비트 23비트

-1이니까 부호비트 1

314.625를 이진수로 ..
> 100111010.101

1.00111010101 x 2^8로 (왼쪽에 1만 남도록)

00111010101을 가수비트에 앞에서 부터 채워주기

8은 지수 비트에서 127(bias)를 더해서 넣기
### 음수 표현법
1의 보수 변환 후 1 더해주기